(function(f){var g;if(typeof window!=='undefined'){g=window}else if(typeof self!=='undefined'){g=self}g.usefetch=f()})(function(){var define,module,exports;
'use strict'

var _$utils_5 = {
  inherit: inherit,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  wait: wait
}

function inherit (Target, Source) {
  Target.prototype = Object.create(Source.prototype, {
    constructor: {
      configurable: true,
      enumerable: false,
      value: Target,
      writable: true
    }
  })
}

function isPlainObject (value) {
  return value != null && Object.prototype.toString.call(value) === '[object Object]'
}

function isUndefined (value) {
  return typeof value === 'undefined'
}

function wait (delay, value) {
  return new Promise(function (resolve) {
    setTimeout(resolve, delay, value)
  })
}

'use strict'

var __inherit_1 = _$utils_5.inherit

var _$errors_1 = {
  UseFetchError: UseFetchError,
  HTTPError: HTTPError,
  ParseError: ParseError,
  TimeoutError: TimeoutError
}

// Using prototype inheritance instead of classes,
// because of incorrect 'instanceof' behavior after
// babel@6 transpiling and terrible workarounds.
function UseFetchError (name, message, response) {
  // Skipping Error constructor call for 'this',
  // cause it acts like 'new Error()' call
  // and returns new error instance instead of
  // attaching `message`, `name` and other stuff to this.
  Object.defineProperties(this, {
    name: { value: name || 'UseFetchError' },
    message: { value: message }
  })

  // captureStackTrace is not defined in safari 12.0.3
  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, this.constructor)
  }

  if (response !== null) {
    Object.assign(this, {
      status: response.status,
      statusText: response.statusText,
      url: response.url
    })
  }

  Object.defineProperty(this, 'response', {
    value: response
  })
}

__inherit_1(UseFetchError, Error)

function HTTPError (response) {
  UseFetchError.call(
    this,
    'HTTPError',
    'Response code ' + response.status + ' (' + response.statusText + ')',
    response
  )
}

__inherit_1(HTTPError, UseFetchError)

function ParseError (error, response) {
  UseFetchError.call(
    this,
    'ParseError',
    error.message + ' in ' + response.url,
    response
  )
}

__inherit_1(ParseError, UseFetchError)

function TimeoutError (threshold) {
  UseFetchError.call(
    this,
    'TimeoutError',
    'Timed out awaiting for ' + threshold + 'ms',
    null
  )
}

__inherit_1(TimeoutError, UseFetchError)

'use strict'

var __isPlainObject_3 = _$utils_5.isPlainObject
var __isUndefined_3 = _$utils_5.isUndefined

var _$normalizeInit_3 = {
  normalizeHeaders: normalizeHeaders,
  normalizeInit: normalizeInit
}

function normalizeHeaders (headers) {
  if (__isPlainObject_3(headers)) {
    return Object.keys(headers).reduce(function (nextHeaders, header) {
      nextHeaders[header.toLowerCase()] = headers[header]
      return nextHeaders
    }, {})
  }

  return {}
}

function normalizeInit (init, defaults) {
  var options = Object.assign({}, defaults, init)

  var headers = Object.assign(
    normalizeHeaders((defaults || {}).headers),
    normalizeHeaders((init || {}).headers)
  )

  if (options.json) {
    if (__isUndefined_3(headers['content-type'])) {
      headers['content-type'] = 'application/json'
    }

    if (__isUndefined_3(headers.accept)) {
      headers.accept = 'application/json'
    }
  }

  var body = options.body
  var method = options.method

  if (body == null) {
    method = method || 'get'
  } else {
    if (options.json) {
      if (__isPlainObject_3(body) || Array.isArray(body)) {
        options.body = JSON.stringify(body)
      } else {
        throw new TypeError('The `body` option must be a plain Object or Array when the `json` option is used')
      }
    }

    method = method || 'post'
  }

  method = method.toUpperCase()

  var retry = {
    retries: typeof options.retry === 'number' ? options.retry : 2,
    methods: ['GET', 'PUT', 'HEAD', 'DEvarE', 'OPTIONS', 'TRACE'],
    statusCodes: [408, 413, 429, 500, 502, 503, 504]
  }

  if (__isPlainObject_3(options.retry)) {
    Object.assign(retry, options.retry)
  }

  return Object.assign(options, {
    headers: headers,
    method: method,
    retry: retry
  })
}

'use strict'

/* global self */
var __HTTPError_4 = _$errors_1.HTTPError
var __ParseError_4 = _$errors_1.ParseError
var __TimeoutError_4 = _$errors_1.TimeoutError
var __wait_4 = _$utils_5.wait
var normalize = _$normalizeInit_3.normalizeInit

// used to compare with response to distinguish real response from timeout
var timeoutResponse = { ok: false }

var _$useFetch_4 = {
  createFetch: createFetch
}

/**
 *
 * @param {string}  input
 * @param {object}  init
 * @param {boolean} init.json
 * @param {boolean} init.throwHttpErrors
 * @param {number}  init.timeout
 */
function usefetch (input, init) {
  var retryCount = 0

  return fetch(input, init)
    .then(handleRetries)
    .then(handleErrors)
    .then(handleResponse)

  function fetch (input, init) {
    if (init.timeout > 0) {
      return Promise.race([
        self.fetch(input, init),
        __wait_4(init.timeout, timeoutResponse)
      ])
    }

    return self.fetch(input, init)
  }

  function handleRetries (response) {
    if (
      (response === timeoutResponse || !response.ok) &&
      init.retry.retries > retryCount &&
      init.retry.methods.includes(init.method) &&
      init.retry.statusCodes.includes(response.status)
    ) {
      // todo check retry-after header
      var timeToWait = 1000 * Math.pow(2, retryCount) + Math.random() * 100
      retryCount++

      return __wait_4(timeToWait)
        .then(function () {
          return fetch(input, init)
        })
        .then(handleRetries)
    }

    return response
  }

  function handleErrors (response) {
    if (response === timeoutResponse) {
      throw new __TimeoutError_4(init.timeout)
    }

    if (!response.ok && init.throwHttpErrors) {
      throw new __HTTPError_4(response)
    }

    return response
  }

  function handleResponse (response) {
    if (init.json) {
      return response.json()
        .then(function (body) {
          Object.defineProperty(response, 'body', {
            configurable: false,
            enumerable: true,
            value: body,
            writable: false
          })

          return response
        })
        .catch(function (error) {
          throw new __ParseError_4(error, response)
        })
    }

    return response
  }
}

function createFetch (defaults) {
  return function (input, init) {
    var options = normalize(init, defaults)
    return usefetch(input, options)
  }
}

'use strict'

var __HTTPError_2 = _$errors_1.HTTPError
var __ParseError_2 = _$errors_1.ParseError
var __TimeoutError_2 = _$errors_1.TimeoutError
var __createFetch_2 = _$useFetch_4.createFetch

var __usefetch_2 = __createFetch_2({
  // spec
  credentials: 'same-origin',
  redirect: 'follow',
  // custom
  json: false,
  retry: 2,
  throwHttpErrors: true,
  timeout: 0
})

__usefetch_2.HTTPError = __HTTPError_2
__usefetch_2.ParseError = __ParseError_2
__usefetch_2.TimeoutError = __TimeoutError_2
__usefetch_2.createFetch = __createFetch_2

var _$usefetch_2 = __usefetch_2

return _$usefetch_2;

});

